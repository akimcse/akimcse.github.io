---
layout: single
title: "250702"
excerpt: "TIL: Process, Thread, Synchronization"

tags:
  - OS
  - Process
  - Thread
---

### 프로세스와 스레드
- `프로세스`: OS로부터 자원을 할당받아 실행중인 작업의 단위 <br>
- `스레드`: 프로세스가 할당받은 자원을 이용하는 실행 흐름의 단위 <br><br>

모든 프로그램은 실행되기 위해 OS가 메모리 공간을 할당해줘야 한다. <br>
이렇게 할당받아서 독립적인 메모리 공간을 갖는, 실행중인 프로그램이 바로 `프로세스`가 된다. <br>

> 프로그램 -> 메모리에 올라감 -> CPU가 자원 할당 -> 실행: 프로세스 

<br>

이때 여러 작업을 해야한다면 아래와 같은 생각을 해볼 수 있다.
- 프로세스를 통으로 하나만 쓰면? -> 멀티태스킹 불가능 <br>
- 하나의 프로그램을 여러 프로세스로 돌리면? -> 메모리 사용 증가, 할당받은 자원 중복 <br>

그래서 나온 방법이 하나의 프로세스를 여러 개의 실행 흐름으로 쪼개는 거다.<br>
하나의 프로세스 안에서 여러 작업을 동시에 진행시킬 때, 각 작업 흐름을 `스레드`라고 하며, 이렇게 여러 스레드를 돌리는 방식이 바로 멀티 스레딩이다. <br><br>

그럼 스레드는 어떻게 하나의 프로세스 안에서 동시 작업이 가능할까?<br>

결론부터 말하면, 스레드끼리 프로세스의 자원을 공유하여 병렬로 작업하면서도 데이터를 함께 사용할 수 있기 때문이다.<br>
이때 스레드는 프로세스의 4가지 메모리 영역 중 Code, Data, Heap을 공유하고, Stack은 별도로 할당받는다. <br>

-> Stack은 함수 호출에 필요한 데이터를 저장하는 공간 <br>
-> 독립적인 Stack을 갖는다는 건 독립적인 함수 호출이 가능하다는 것 <br>
-> 독립적인 함수 호출이 가능하다는 건 독립적인 실행 흐름을 가질 수 있다는 것!

<br>

### Context Switching
CPU는 한 번에 하나의 프로세스만 실행할 수 있다. <br>
따라서 CPU 활용율을 높이기 위해서는 여러 개의 프로세스를 번갈아가며 사용(동시성)하는 `Context Switching`이 필요하다. <br>

> 실행 중인 프로세스 A 대기 -> 프로세스 A 상태 보관 -> 다음 프로세스 B의 이전 상태 복구 -> 프로세스 B 실행 

이때 다음 프로세스는 스케줄러가 결정한다. <br>
즉, 컨텍스트 스위칭의 주체는 스케줄러다. <br><br>

그럼 전환 시 필요한 프로세스의 상태 정보는 어디에 저장될까? -> `PCB`(Process Control Block) ! <br>
- 프로세스의 상태 정보를 담는 자료구조
- 프로세스 생성 및 종료와 함께 PCB도 생성, 삭제됨
- 프로세스를 관리하기 위해 필요한 핵심 정보가 담겨 있으므로 커널 영역에 저장됨
- Linked List 방식으로 관리되어 삽입 삭제가 용이함

<br>

그럼 스레드의 컨텍스트 스위칭에 필요한 정보는? -> `TCB`(Thread Control Block) !
- PCB 내부에 들어있음
- 스레드의 생성 및 종료와 함께 생성, 삭제됨

<br>

### Synchronization
멀티 프로세스, 혹은 멀티 스레드 환경은 자원을 공유(멀티 프로세스 환경의 경우 IPC 통신 등으로)하므로 `race condition`에 도달할 수 있다. <br>
이때 둘 이상의 프로세스나 스레드가 동시에 접근하면 안되는 코드 영역이나 자원 사용 구간을 `critical section`이라고 한다. 임계 영역에는 반드시 하나의 흐름만 진입해야 한다. <br>
즉, 동시성 프로그래밍의 가장 큰 숙제는 바로 '공유 자원 관리'다. <br><br>

`Synchronization`은 여러 작업이 동시에 공유 자원에 접근할 때 충돌이나 일관성 문제를 막기 위한 기술로, 동기화 기법에는 크게 아래 두 가지가 있다. <br>

1. `Mutex`: 공유 자원이 한 프로세스, 스레드에 의해 소유될 수 있는 key를 기반으로 하는 상호배제 기법 <br>
> 딱 한 칸만 있는 화장실에 들어가려면 카운터에서 키를 받아가야만 한다!
- 이진 락(접근 가능 or 불가능)
- 동시 접근 불가(독점)
- 락을 건 주체만이 해제 가능함(소유권을 가지는 락의 개념)

-> 파일 쓰기, 전역 변수 접근과 같은 임계 구역 보호 등 단일 자원 보호에 적합 <br><br>

2. `Semaphore`: 현재 공유 자원이 접근할 수 있는 프로세스, 스레드의 수를 나타내는 값을 기반으로 한 상호배제 기법 <br>
> 칸이 여러개인 화장실의 이용 현황 보드를 누구나 수정할 수 있으며, 보고 빈칸이 있으면 들어간다!
- 정수 카운터(n개 접근 가능)
- 동시 접근 가능
- 아무 스레드나 락 해제 가능(누구나 수정하는 카운터 개념)

-> 뮤텍스보다 일반화된 동기화로, 리소스 풀 제어 등 여러 스레드의 공유 자원 접근 제어에 적합
